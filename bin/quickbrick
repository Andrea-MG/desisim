#!/usr/bin/env python

"""
quickbrick - quickly generate DESI brick files

Stephen Bailey
Lawrence Berkeley National Lab
Fall 2015
"""

import sys, os
import numpy as np

from astropy.table import Column

import desimodel.io
import specsim
import desispec

import desisim.templates
import desisim.obs

#- Parse command line options
import optparse
parser = optparse.OptionParser(usage = "%prog [options]")
parser.add_option("-b", "--brickname", type=str,  help="brickname")
parser.add_option(      "--objtype", type=str,  help="elg,lrg,qso,star, or sky")
parser.add_option("-n", "--nspec", type=int,  help="number of spectra to simulate")
parser.add_option("-o", "--outdir", type=str,  help="output data directory; default .", default='.')
#- TODO: look up canonical default airmass
parser.add_option("-a", "--airmass", type=float,  help="airmass [%default]", default=1.1)
parser.add_option("--outdir_truth", type=str,  help="optional alternative outdir for truth files")
opts, args = parser.parse_args()

desiparams = desimodel.io.load_desiparams()

#- Check options.  TODO: make this better
assert opts.brickname is not None
assert opts.objtype is not None
opts.objtype = opts.objtype.upper()
assert opts.objtype in ['ELG', 'LRG', 'QSO', 'STAR', 'SKY']

#- Create the atmosphere module and the quick simulator object
atmosphere = specsim.atmosphere.Atmosphere(
    skyConditions='dark', basePath=os.environ['DESIMODEL'])
qsim = specsim.quick.Quick(
    atmosphere=atmosphere, basePath=os.environ['DESIMODEL'])

#- Wavelength grid to cover all channels
wavemin = desimodel.io.load_throughput('b').wavemin
wavemax = desimodel.io.load_throughput('z').wavemax
wavestep = 1.0  #- TODO: 1.0 A for testing; make finer grid later
wave = np.arange(wavemin, wavemax, wavestep)

#- Generate a set of templates
#- TODO: support multiple input types
if opts.objtype == 'ELG':
    elg = desisim.templates.ELG(opts.nspec, wave=wave)
    flux, tmpwave, meta = elg.make_templates()
elif opts.objtype == 'LRG':
    lrg = desisim.templates.LRG(opts.nspec, wave=wave)
    flux, tmpwave, meta = lrg.make_templates()
elif opts.objtype == 'QSO':
    qso = desisim.templates.QSO(opts.nspec, wave=wave)
    flux, tmpwave, meta = qso.make_templates()
elif opts.objtype == 'STAR':
    star = desisim.templates.STAR(opts.nspec, wave=wave)
    flux, tmpwave, meta = star.make_templates()
elif opts.objtype == 'SKY':
    flux = np.zeros((opts.nspec, len(wave)))
    meta = Table(dict(REDSHIFT=np.zeros(opts.nspec, dtype=np.float32)))

#- sanity check on units; templates currently return ergs, not 1e-17 ergs...
assert (opts.objtype == 'SKY') or (np.max(flux) < 1e-6)

#- Create a blank fake fibermap; this is re-used by all channels
fibermap = desispec.io.empty_fibermap(opts.nspec)
targetids = np.random.randint(2**62, size=opts.nspec)
fibermap['TARGETID'] = targetids
night = desisim.obs.get_night()
expid = 0

#- Add TARGETID and the true OBJTYPE to the template meta table
meta.add_column(Column([opts.objtype,]*opts.nspec, name='OBJTYPE'))
meta.add_column(Column(targetids, name='TARGETID'))

for channel in ['b', 'r', 'z']:
    #- get wavelength grid for this channel
    t = desimodel.io.load_throughput(channel)
    qsim.setWavelengthGrid(t.wavemin, t.wavemax, wavestep)
    ii = np.where((t.wavemin <= wave) & (wave < t.wavemax))[0]
    obswave = wave[ii]

    #- resolution matrix is pre-calculated but doesn't cover all wavelengths
    #- HACK HACK HACK: pull out piece that is actually used
    j = qsim.instrument.cameraBands.index(channel)
    R = qsim.cameras[j].sparseKernel
    goodwave = np.where(np.sum(R.toarray(), axis=0) > 0)[0]
    Rdata = R[goodwave][:,goodwave].todia().data  #- [goodwave, goodwave] doesn't work

    #- Fill these in as we go
    trueflux = np.zeros((opts.nspec, len(ii)))
    obsflux = np.zeros((opts.nspec, len(ii)))
    obsivar = np.zeros((opts.nspec, len(ii)))

    fluxunits = specsim.spectrum.SpectralFluxDensity.fiducialFluxUnit * 1e17
    for i in range(opts.nspec):
        inspec = specsim.spectrum.SpectralFluxDensity(obswave, flux[i,ii], fluxUnits=fluxunits)
        results = qsim.simulate(sourceType=opts.objtype.lower(), sourceSpectrum=inspec, 
            airmass = opts.airmass, expTime = desiparams['exptime'], downsampling=1)

        sigma = 1/np.sqrt(results.ivar.clip(1e-12, 1e12))  #- avoid divide by 0
        noise = np.random.normal(loc=0.0, scale=sigma, size=results.obsflux.shape)
        trueflux[i] = results.obsflux
        obsflux[i] = results.obsflux + noise
        obsivar[i] = results.ivar

    #- replicate resolution matrix for each spectrum
    Rdata = np.array([Rdata for i in range(opts.nspec)])

    #- Write brick output
    filename = 'brick-{}-{}.fits'.format(channel, opts.brickname)
    filepath = os.path.join(opts.outdir, filename)
    if os.path.exists(filepath):
        os.remove(filepath)

    header = dict(BRICKNAM=opts.brickname, CHANNEL=channel)
    brick = desispec.io.Brick(filepath, mode='update', header=header)        
    brick.add_objects(obsflux[:,goodwave], obsivar[:,goodwave],
        obswave[goodwave], Rdata, fibermap, night, expid)
    brick.close()

    #- Append truth to the file
    from astropy.io import fits
    fx = fits.open(filepath, mode='append')
    header = desispec.io.fitsheader(header)
    fx.append(fits.ImageHDU(trueflux[:,goodwave].astype(np.float32), name='_TRUEFLUX', header=header))
    fx.append(fits.BinTableHDU(meta.as_array(), name='_TRUTH'))
    fx.flush()
    fx.close()
    
