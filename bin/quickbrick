#!/usr/bin/env python

"""
quickbrick - quickly generate DESI brick files

Stephen Bailey
Lawrence Berkeley National Lab
Fall 2015
"""

import sys, os
import numpy as np
import scipy.sparse

from astropy.table import Table, Column, vstack

import desimodel.io
import specsim
import desispec

import desisim.templates
import desisim.obs

import pylab # DEBUG

#- Parse command line options
import optparse
parser = optparse.OptionParser(usage = "%prog [options]")
parser.add_option("-b", "--brickname", type=str,  help="brickname")
parser.add_option(      "--objtype", type=str,  help="elg,lrg,qso,star, or sky")
parser.add_option("-n", "--nspec", type=int,  help="number of spectra to simulate")
parser.add_option("-o", "--outdir", type=str,  help="output data directory; default .", default='.')
#- Average DESI airmass 1.25; (See Science Req. Doc L3.3.2)
parser.add_option("-a", "--airmass", type=float,  help="airmass [%default]", default=1.25)
parser.add_option("-t", "--testwavelength", type=float,  help="test quickbrick with a single emission line", default=None)

parser.add_option("--outdir_truth", type=str,  help="optional alternative outdir for truth files", default=None)
opts, args = parser.parse_args()

desiparams = desimodel.io.load_desiparams()

#- Check options.  TODO: make this better
assert opts.brickname is not None
assert opts.objtype is not None
opts.objtype = opts.objtype.upper()
assert opts.objtype in ['ELG', 'LRG', 'QSO', 'STAR', 'SKY','TEST']
    
#- Create the atmosphere module and the quick simulator object
atmosphere = specsim.atmosphere.Atmosphere(
    skyConditions='dark', basePath=os.environ['DESIMODEL'])
qsim = specsim.quick.Quick(
    atmosphere=atmosphere, basePath=os.environ['DESIMODEL'])

#- Wavelength grid to cover all channels
wavemin = desimodel.io.load_throughput('b').wavemin
wavemax = desimodel.io.load_throughput('z').wavemax
wavestep = 0.2      #- TODO: refine the resolution and downsampling params
downsampling = 3
wave = np.arange(wavemin-1, wavemax+1, wavestep)



#- Generate a set of templates
#- TODO: support multiple input types
if opts.objtype == 'ELG':
    elg = desisim.templates.ELG(opts.nspec, wave=wave)
    flux, tmpwave, meta = elg.make_templates()
elif opts.objtype == 'LRG':
    lrg = desisim.templates.LRG(opts.nspec, wave=wave)
    flux, tmpwave, meta = lrg.make_templates()
elif opts.objtype == 'QSO':
    qso = desisim.templates.QSO(opts.nspec, wave=wave)
    flux, tmpwave, meta = qso.make_templates()
elif opts.objtype == 'STAR':
    star = desisim.templates.STAR(opts.nspec, wave=wave)
    flux, tmpwave, meta = star.make_templates()
elif opts.objtype == 'SKY':
    flux = np.zeros((opts.nspec, len(wave)))
    meta = Table(dict(REDSHIFT=np.zeros(opts.nspec, dtype=np.float32)))
elif opts.objtype == 'TEST':
    opts.objtype='STAR' # for specsim
    flux = np.zeros((opts.nspec, len(wave)))
    i=np.where(wave>5800.-1e-6)[0][0]
    ref_integrated_flux=1.e-10
    ref_cst_flux_density=1.e-17
    
    single_line = (np.arange(opts.nspec)%2 == 0).astype(np.float32)
    continuum   = (np.arange(opts.nspec)%2 == 1).astype(np.float32)
    
    for spec in range(opts.nspec) :
        flux[spec,i] = single_line[spec]*ref_integrated_flux/np.gradient(wave)[i] # single line
        flux[spec]   += continuum[spec]*ref_cst_flux_density # flat continuum
            
    #print "ref wave=",wave[i]
    #print "ref integrated flux=",ref_integrated_flux,"ergs/s/cm2"
    meta = Table(dict(REDSHIFT=np.zeros(opts.nspec, dtype=np.float32),
                      LINE=wave[i]*np.ones(opts.nspec, dtype=np.float32),
                      LINEFLUX=single_line*ref_integrated_flux,
                      CONSTFLUXDENSITY=continuum*ref_cst_flux_density))
    


#- sanity check on units; templates currently return ergs, not 1e-17 ergs...
assert (opts.objtype == 'SKY') or (np.max(flux) < 1e-6)

#- Create a blank fake fibermap; this is re-used by all channels
fibermap = desispec.io.empty_fibermap(opts.nspec)
targetids = np.random.randint(2**62, size=opts.nspec)
fibermap['TARGETID'] = targetids
night = desisim.obs.get_night()
expid = 0

#- Add TARGETID and the true OBJTYPE to the template meta table
meta.add_column(Column([opts.objtype,]*opts.nspec, name='OBJTYPE'))
meta.add_column(Column(targetids, name='TARGETID'))

#- rename REDSHIFT -> TRUEZ anticipating later table joins with zbest.Z
meta.rename_column('REDSHIFT', 'TRUEZ')


#- Actually do the simulations for each target
fluxunits = specsim.spectrum.SpectralFluxDensity.fiducialFluxUnit * 1e17
qsim.setWavelengthGrid(wavemin, wavemax, wavestep)

#- output arrays to fill; these cover wavelengths across all cameras
trueflux={}
obsivar={}
obswave=None
for channel in qsim.instrument.cameraBands :
    trueflux[channel]=list()
    obsivar[channel]=list()

#- convert list of arrays to 2D arrays
for i in range(opts.nspec):
    inspec = specsim.spectrum.SpectralFluxDensity(wave, flux[i], fluxUnits=fluxunits)
            
    results = qsim.simulate(sourceType=opts.objtype.lower(), sourceSpectrum=inspec, 
        airmass = opts.airmass, expTime = desiparams['exptime'], downsampling=downsampling)
    
    #- output wavelength grid is the same for all spectra
    if obswave is None :
        obswave=results.wave
    else :
        assert (np.sum((obswave-results.wave)**2)==0.)
    
    # now we collect the results
    for channel in qsim.instrument.cameraBands :
        j = qsim.instrument.cameraBands.index(channel)
        trueflux[channel].append(results.camflux[:,j])
        obsivar[channel].append(results.camivar[:,j])
pylab.show() # DEBUG
    
#- convert list of arrays to 2D arrays
for channel in qsim.instrument.cameraBands :
    trueflux[channel] = np.array(trueflux[channel])
    obsivar[channel] = np.array(obsivar[channel])


#- add noise
noisyflux={}
for channel in qsim.instrument.cameraBands :
    noisyflux[channel] = np.zeros_like(trueflux[channel])
    ii = np.where(obsivar[channel] > 0)
    sigma = 1/np.sqrt(obsivar[channel][ii])
    noisyflux[channel][ii] = trueflux[channel][ii] + np.random.normal(loc=0, scale=sigma)
    

#- Select the wavelengths for each camera and output brick files
for channel in ['b', 'r', 'z']:    
    #- Sparse full resolution matrix for this camera
    j = qsim.instrument.cameraBands.index(channel)
    R = qsim.cameras[j].sparseKernel
        
    #- Trim R to range with non-zeros in even multiples of the downsampling
    nd = downsampling
    ii = np.where(R.sum(axis=0).A[0])[0]
    begin, end = (ii[0]//nd)*nd, ((ii[-1]+1)//nd)*nd
    R = R[begin:end, begin:end]
    
    #- indices of downsampled flux, ivar to keep
    iiobs = np.arange(begin, end, nd) // nd
        
    #- Downsample the resolution matrix
    s = R.shape[1]//nd, nd, R.shape[0]//nd, nd
    Rx = R.toarray().reshape(s).sum(-1).sum(1) / nd
    Rdata = scipy.sparse.dia_matrix(Rx).data
    
    #- replicate for all spectra for the output file
    Rdata = np.array([Rdata for i in range(opts.nspec)])

    #- Write brick output
    filename = 'brick-{}-{}.fits'.format(channel, opts.brickname)
    filepath = os.path.join(opts.outdir, filename)
    if os.path.exists(filepath):
        os.remove(filepath)

    header = dict(BRICKNAM=opts.brickname, CHANNEL=channel)
    brick = desispec.io.Brick(filepath, mode='update', header=header)        
    brick.add_objects(noisyflux[channel][:,iiobs], obsivar[channel][:,iiobs],
        obswave[iiobs], Rdata, fibermap, night, expid)
    brick.close()

    #- Append truth to the file
    #- Note: Resolution convolved true flux, not high resolution source flux;
    #-       This makes chi2 calculations easier
    from astropy.io import fits

    if opts.outdir_truth is None : # add truth in same file
        fx = fits.open(filepath, mode='append')
        header = desispec.io.fitsheader(header)
        fx.append(fits.ImageHDU(trueflux[channel][:,iiobs].astype(np.float32), name='_TRUEFLUX', header=header))
        fx.append(fits.BinTableHDU(meta.as_array(), name='_TRUTH'))
        fx.flush()
        fx.close()
    else :
        header = desispec.io.fitsheader(header)
        hdulist = fits.HDUList([fits.PrimaryHDU(header=header)])        
        hdulist.append(fits.ImageHDU(trueflux[channel][:,iiobs].astype(np.float32), name='_TRUEFLUX', header=header))
        hdulist.append(fits.BinTableHDU(meta.as_array(), name='_TRUTH'))
        filename = 'truth-brick-{}-{}.fits'.format(channel, opts.brickname)
        filepath = os.path.join(opts.outdir_truth, filename)
        hdulist.writeto(filepath,clobber=True)
        
    
