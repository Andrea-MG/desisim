#!/usr/bin/env python

"""
quickbrick - quickly generate DESI brick files

Stephen Bailey
Lawrence Berkeley National Lab
Fall 2015
"""

import sys, os
import numpy as np
import scipy.sparse

from astropy.table import Table, Column, vstack

import desimodel.io
import specsim
import desispec

import desisim.templates
import desisim.obs

#- Parse command line options
import optparse
parser = optparse.OptionParser(usage = "%prog [options]")
parser.add_option("-b", "--brickname", type=str,  help="brickname")
parser.add_option(      "--objtype", type=str,  help="elg,lrg,qso,star, or sky")
parser.add_option("-n", "--nspec", type=int,  help="number of spectra to simulate")
parser.add_option("-o", "--outdir", type=str,  help="output data directory; default .", default='.')
#- Average DESI airmass 1.25; (See Science Req. Doc L3.3.2)
parser.add_option("-a", "--airmass", type=float,  help="airmass [%default]", default=1.25)
parser.add_option("--outdir_truth", type=str,  help="optional alternative outdir for truth files")
opts, args = parser.parse_args()

desiparams = desimodel.io.load_desiparams()

#- Check options.  TODO: make this better
assert opts.brickname is not None
assert opts.objtype is not None
opts.objtype = opts.objtype.upper()
assert opts.objtype in ['ELG', 'LRG', 'QSO', 'STAR', 'SKY']

#- Create the atmosphere module and the quick simulator object
atmosphere = specsim.atmosphere.Atmosphere(
    skyConditions='dark', basePath=os.environ['DESIMODEL'])
qsim = specsim.quick.Quick(
    atmosphere=atmosphere, basePath=os.environ['DESIMODEL'])

#- Wavelength grid to cover all channels
wavemin = desimodel.io.load_throughput('b').wavemin
wavemax = desimodel.io.load_throughput('z').wavemax
wavestep = 0.2      #- TODO: refine the resolution and downsampling params
downsampling = 3
wave = np.arange(wavemin-1, wavemax+1, wavestep)

#- Generate a set of templates
#- TODO: support multiple input types
if opts.objtype == 'ELG':
    elg = desisim.templates.ELG(opts.nspec, wave=wave)
    flux, tmpwave, meta = elg.make_templates()
elif opts.objtype == 'LRG':
    lrg = desisim.templates.LRG(opts.nspec, wave=wave)
    flux, tmpwave, meta = lrg.make_templates()
elif opts.objtype == 'QSO':
    qso = desisim.templates.QSO(opts.nspec, wave=wave)
    flux, tmpwave, meta = qso.make_templates()
elif opts.objtype == 'STAR':
    star = desisim.templates.STAR(opts.nspec, wave=wave)
    flux, tmpwave, meta = star.make_templates()
elif opts.objtype == 'SKY':
    flux = np.zeros((opts.nspec, len(wave)))
    meta = Table(dict(REDSHIFT=np.zeros(opts.nspec, dtype=np.float32)))

#- sanity check on units; templates currently return ergs, not 1e-17 ergs...
assert (opts.objtype == 'SKY') or (np.max(flux) < 1e-6)

#- Create a blank fake fibermap; this is re-used by all channels
fibermap = desispec.io.empty_fibermap(opts.nspec)
targetids = np.random.randint(2**62, size=opts.nspec)
fibermap['TARGETID'] = targetids
night = desisim.obs.get_night()
expid = 0

#- Add TARGETID and the true OBJTYPE to the template meta table
meta.add_column(Column([opts.objtype,]*opts.nspec, name='OBJTYPE'))
meta.add_column(Column(targetids, name='TARGETID'))

#- rename REDSHIFT -> TRUEZ anticipating later table joins with zbest.Z
meta.rename_column('REDSHIFT', 'TRUEZ')

#- output arrays to fill; these cover wavelengths across all cameras
trueflux = list()
srcflux = list()
obsivar = list()

#- Actually do the simulations for each target
fluxunits = specsim.spectrum.SpectralFluxDensity.fiducialFluxUnit * 1e17
qsim.setWavelengthGrid(wavemin, wavemax, wavestep)
for i in range(opts.nspec):
    inspec = specsim.spectrum.SpectralFluxDensity(wave, flux[i], fluxUnits=fluxunits)
    results = qsim.simulate(sourceType=opts.objtype.lower(), sourceSpectrum=inspec, 
        airmass = opts.airmass, expTime = desiparams['exptime'], downsampling=downsampling)
        
    trueflux.append(results.obsflux)
    srcflux.append(results.srcflux)
    obsivar.append(results.ivar)
    
#- convert list of arrays to 2D arrays
trueflux = np.array(trueflux)
srcflux = np.array(srcflux)
obsivar = np.array(obsivar)
    
#- add noise
noisyflux = np.zeros_like(trueflux)
ii = np.where(obsivar > 0)
sigma = 1/np.sqrt(obsivar[ii])
noisyflux[ii] = trueflux[ii] + np.random.normal(loc=0, scale=sigma)
    
#- output wavelength grid is the same for all spectra
obswave = results.wave

#- Select the wavelengths for each camera and output brick files
for channel in ['b', 'r', 'z']:    
    #- Sparse full resolution matrix for this camera
    j = qsim.instrument.cameraBands.index(channel)
    R = qsim.cameras[j].sparseKernel
        
    #- Trim R to range with non-zeros in even multiples of the downsampling
    nd = downsampling
    ii = np.where(R.sum(axis=0).A[0])[0]
    begin, end = (ii[0]//nd)*nd, ((ii[-1]+1)//nd)*nd
    R = R[begin:end, begin:end]
    
    #- indices of downsampled flux, ivar to keep
    iiobs = np.arange(begin, end, nd) // nd
        
    #- Downsample the resolution matrix
    s = R.shape[1]//nd, nd, R.shape[0]//nd, nd
    Rx = R.toarray().reshape(s).sum(-1).sum(1) / nd
    Rdata = scipy.sparse.dia_matrix(Rx).data
    
    #- replicate for all spectra for the output file
    Rdata = np.array([Rdata for i in range(opts.nspec)])

    #- Write brick output
    filename = 'brick-{}-{}.fits'.format(channel, opts.brickname)
    filepath = os.path.join(opts.outdir, filename)
    if os.path.exists(filepath):
        os.remove(filepath)

    header = dict(BRICKNAM=opts.brickname, CHANNEL=channel)
    brick = desispec.io.Brick(filepath, mode='update', header=header)        
    brick.add_objects(noisyflux[:,iiobs], obsivar[:,iiobs],
        obswave[iiobs], Rdata, fibermap, night, expid)
    brick.close()

    #- Append truth to the file
    #- Note: Resolution convolved true flux, not high resolution source flux;
    #-       This makes chi2 calculations easier
    from astropy.io import fits
    fx = fits.open(filepath, mode='append')
    header = desispec.io.fitsheader(header)
    fx.append(fits.ImageHDU(trueflux[:,iiobs].astype(np.float32), name='_TRUEFLUX', header=header))
    fx.append(fits.BinTableHDU(meta.as_array(), name='_TRUTH'))
    fx.flush()
    fx.close()
    
